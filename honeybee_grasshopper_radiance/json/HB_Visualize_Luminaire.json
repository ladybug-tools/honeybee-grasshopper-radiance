{
  "version": "1.9.0", 
  "nickname": "VizLuminaire", 
  "outputs": [
    [
      {
        "access": "None", 
        "name": "lum_poly", 
        "description": "Geometric representation of the luminous opening.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "lum_web", 
        "description": "Geometric representation of the candela distribution of the luminaire.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "lum_axes", 
        "description": "Line representation of the C0-G0 axes of the luminaire.", 
        "type": null, 
        "default": null
      }
    ]
  ], 
  "inputs": [
    {
      "access": "item", 
      "name": "_luminaire", 
      "description": "A Honeybee Luminaire.", 
      "type": "System.Object", 
      "default": null
    }, 
    {
      "access": "item", 
      "name": "_scale_", 
      "description": "A scalar value to scale the geometry.", 
      "type": "double", 
      "default": null
    }
  ], 
  "subcategory": "2 :: Light Sources", 
  "code": "\nimport {{Cad}} as rc\nimport math\nfrom {{Cad}}.Geometry import Point3d, PolyCurve, Brep, Line\nimport scriptcontext as sc\nimport copy\nfrom ladybug_geometry.geometry3d.pointvector import Vector3D, Point3D\nfrom ladybug_geometry.geometry3d.polyline import Polyline3D\nfrom ladybug_geometry.geometry3d.face import Face3D\nfrom ladybug_{{cad}}.fromgeometry import from_face3d\n\ntry:\n    from ladybug_{{cad}}.{{plugin}} import all_required_inputs, list_to_data_tree,   \\\n        give_warning\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_{{cad}}:\\n\\t{}'.format(e))\n\n\ndef luminaire_web_to_{{cad}}_breps(luminaire, normalize=True):\n    \"\"\"Generate geometric representation of the candela distribution of a luminaire.\n    \n    Args:\n        luminaire: A Honeybee Luminaire.\n        normalize: Set to True to Normalize candela values.\n    \n    Returns:\n        List[{{Cad}}.Geometry.Brep]\n    \"\"\"\n\n    # Ensure photometry is parsed\n    luminaire.parse_photometric_data()\n\n    # Expand symmetry\n    horz_deg, candelas = luminaire._expand_horizontal_angles(\n        luminaire.horizontal_angles,\n        luminaire.candela_values\n    )\n\n    vert_deg = luminaire.vertical_angles\n\n    # Convert to radians\n    horz = [math.radians(h) for h in horz_deg]\n    vert = [math.radians(v) for v in vert_deg]\n\n    # Normalize candela\n    if normalize:\n        max_cd = luminaire.max_candela or 1.0\n        candelas = [\n            [v / max_cd for v in row]\n            for row in candelas\n        ]\n\n    # Scale = max luminous dimension\n    mul3d = max(abs(luminaire.width_m), abs(luminaire.length_m))\n\n    # Create vertical-angle curves\n    curves = []\n\n    for h_idx, h_ang in enumerate(horz):\n        pts = []\n\n        for v_idx, v_ang in enumerate(vert):\n            cd = mul3d * candelas[h_idx][v_idx]\n\n            x = cd * math.sin(v_ang) * math.cos(h_ang)\n            y = cd * math.sin(v_ang) * math.sin(h_ang)\n            z = -cd * math.cos(v_ang)\n\n            pts.append(Point3d(x, y, z))\n\n        curves.append(PolyCurve.CreateControlPointCurve(pts))\n\n    # Create edge surfaces between curves\n    breps = []\n\n    for i in range(len(curves) - 1):\n        b = Brep.CreateEdgeSurface([curves[i], curves[i + 1]])\n        if b:\n            breps.append(b)\n\n    return breps\n\n\ndef luminaire_web_to_ladybug_faces(luminaire, normalize=True):\n    \"\"\"Generate a Ladybug-geometry photometric web.\n    \n    Args:\n        luminaire: A Honeybee Luminaire.\n        normalize: Set to True to Normalize candela values.\n    \n    Returns:\n        List[Face3D]\n    \"\"\"\n\n    luminaire.parse_photometric_data()\n\n    horz_deg, candelas = luminaire._expand_horizontal_angles(\n        luminaire.horizontal_angles,\n        luminaire.candela_values\n    )\n\n    vert_deg = luminaire.vertical_angles\n\n    horz = [math.radians(h) for h in horz_deg]\n    vert = [math.radians(v) for v in vert_deg]\n\n    if normalize:\n        max_cd = luminaire.max_candela or 1.0\n        candelas = [[v / max_cd for v in row] for row in candelas]\n\n    scale = max(abs(luminaire.width_m), abs(luminaire.length_m))\n\n    # Build vertical-angle polylines\n    curves = []\n\n    for h_idx, h_ang in enumerate(horz):\n        pts = []\n        for v_idx, v_ang in enumerate(vert):\n            cd = scale * candelas[h_idx][v_idx]\n\n            x = cd * math.sin(v_ang) * math.cos(h_ang)\n            y = cd * math.sin(v_ang) * math.sin(h_ang)\n            z = -cd * math.cos(v_ang)\n\n            pts.append(Point3D(x, y, z))\n\n        curves.append(Polyline3D(pts))\n\n    # Create quad faces between adjacent curves\n    faces = []\n\n    for i in range(len(curves) - 1):\n        c0 = curves[i].vertices\n        c1 = curves[i + 1].vertices\n\n        for j in range(len(c0) - 1):\n            face = Face3D((c0[j], c0[j + 1], c1[j + 1], c1[j]))\n            faces.append(face)\n\n    return faces\n\n\ndef transform_geometry(geometry, spin=0, tilt=0, rotation=0, translation=(0,0,0), scale=1.0):\n    \"\"\"Transform a geometry or list of geometries based on spin, tilt, rotation,\n    translation, scale.\n    \n    Args:\n        geometry: \"\"\"\n    if not isinstance(geometry, list):\n        geometry = [geometry]\n    geometry = [copy.deepcopy(g) for g in geometry]\n\n    norm_vec = rc.Geometry.Vector3d(0, 0, 1)\n    plane = rc.Geometry.Plane(rc.Geometry.Point3d(0, 0, 0), norm_vec)\n    origin = rc.Geometry.Point3d(0, 0, 0)\n\n    # Scale\n    if scale != 1.0:\n        s = rc.Geometry.Transform.Scale(plane, scale, scale, scale)\n        for g in geometry: g.Transform(s)\n\n    # Spin (Z-axis)\n    if spin != 0:\n        t = rc.Geometry.Transform.Rotation(math.radians(spin), rc.Geometry.Vector3d.ZAxis, origin)\n        for g in geometry: g.Transform(t)\n\n    # Tilt (Y-axis)\n    if tilt != 0:\n        t = rc.Geometry.Transform.Rotation(math.radians(tilt), rc.Geometry.Vector3d.YAxis, origin)\n        for g in geometry: g.Transform(t)\n\n    # Rotate (Z-axis)\n    if rotation != 0:\n        t = rc.Geometry.Transform.Rotation(math.radians(rotation), rc.Geometry.Vector3d.ZAxis, origin)\n        for g in geometry: g.Transform(t)\n\n    # Translate\n    x, y, z = translation\n    t = rc.Geometry.Transform.Translation(x, y, z)\n    for g in geometry: g.Transform(t)\n\n    return geometry if len(geometry) > 1 else geometry[0]\n\n\ndef place_luminaire_from_object(luminaire, luminaire_web, scale):\n    \"\"\"Take a Luminaire object, place its geometry at all points in its LuminaireZone,\n    applying spin, tilt, and rotation.\n    \n    Args:\n        luminaire: A Honeybee Luminaire.\n        luminaire_web: Geometric representation of the candela distribution of\n            of the luminaire.\n        scale: Scalar value to scale the geometry.\n    \n    Returns:\n        List[{{Cad}}.Geometry.Brep]\n    \"\"\"\n    if luminaire.luminaire_zone is None:\n        return [luminaire_web]\n\n    luminaire_zone = luminaire.luminaire_zone\n    geometry = []\n\n    for instance in luminaire_zone.instances:\n        geo = transform_geometry(\n            luminaire_web,\n            spin=instance.spin,\n            tilt=instance.tilt,\n            rotation=instance.rotation,\n            translation=instance.point,\n            scale=scale\n        )\n        geometry.append(geo)\n\n    return geometry\n\n\ndef create_luminaire_brep(luminaire):\n    \"\"\"Create geometric representation of the luminous opening of a Luminaire.\n    \n    Args:\n        luminaire: A Honeybee Luminaire.\n    \n    Returns:\n        List[{{Cad}}.Geometry.Brep]\n    \"\"\"\n    w = luminaire.width_m\n    l = luminaire.length_m\n    h = luminaire.height_m\n\n    plane = rc.Geometry.Plane.WorldXY\n    origin = rc.Geometry.Point3d.Origin\n    breps = []\n\n    # Implies that the luminous opening is a point\n    if round(w, 2) == 0 and round(l, 2) == 0 and round(h, 2) == 0:\n        return []\n    # Implies that luminous opening is rectangular\n    elif w > 0 and l > 0 and round(h, 2) == 0:\n        corner_a = rc.Geometry.Point3d(-l/2, -w/2, 0)\n        corner_b = rc.Geometry.Point3d(l/2, w/2, 0)\n        lum_rect = rc.Geometry.Rectangle3d(plane, corner_a, corner_b).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_rect])[0]\n    # Implies that luminous opening is rectangular with luminous sides\n    elif w > 0 and l > 0 and h> 0:\n        x_interval = rc.Geometry.Interval(-l/2, l/2)\n        y_interval = rc.Geometry.Interval(-w/2, w/2)\n        z_interval = rc.Geometry.Interval(-h/2, h/2)\n        lum_poly = rc.Geometry.Box(plane, x_interval, y_interval, z_interval)\n    # Implies that the luminous opening is a circle  \n    elif w < 0 and l < 0 and round(l, 2) == round(w, 2) and round(h, 2) == 0:\n        lum_circ = rc.Geometry.Circle(plane ,origin, abs(-w/2)).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_circ])[0]\n    elif w < 0 and round(l, 2) == 0 and round(h, 2) == 0:\n        lum_circ = rc.Geometry.Circle(plane, origin, abs(-w/2)).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_circ])[0]\n    # Implies that the luminous opening is an ellipse\n    elif w < 0 and l < 0 and round(l, 2) != round(w, 2) and round(h, 2) == 0:\n        lum_ellip = rc.Geometry.Ellipse(plane, abs(-w/2), abs(-l/2)).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_ellip])[0]\n    # Implies the luminous opening is a vertical cylinder\n    elif w < 0 and l < 0 and h > 0 and round(l, 2) == round(w, 2):\n        lum_circ = rc.Geometry.Circle(plane, origin, abs(-w/2))\n        lum_poly = rc.Geometry.Cylinder(lum_circ, h).ToBrep(True, True)\n    # Implies the luminous opening is a vertical elliptcal cylinder\n    elif w < 0 and l < 0 and h > 0 and round(l, 2) != round(w, 2):\n        lum_circ = rc.Geometry.Circle(plane, origin, 1)\n        lum_poly = rc.Geometry.Cylinder(lum_circ, 1).ToNurbsSurface()\n        transf = rc.Geometry.Transform.Scale(plane, abs(w/2), abs(l/2), abs(h))\n        lum_poly.Transform(transf)\n        lum_poly = lum_poly.ToBrep().CapPlanarHoles(sc.doc.ModelAbsoluteTolerance)\n    elif w < 0 and l < 0 and h < 0 and round(l, 2) == round(w, 2) and round(w, 2) == round(h, 2):\n        lum_poly = rc.Geometry.Sphere(rc.Geometry.Point3d(0, 0, abs(w/2)), abs(w/2))\n    # Implies the luminous opening is an ellipsoid\n    elif w < 0 and l < 0 and h < 0:\n        lum_poly = rc.Geometry.Sphere(rc.Geometry.Point3d(0, 0, abs(w/2)), 1).ToNurbsSurface()\n        transf = rc.Geometry.Transform.Scale(rc.Geometry.Plane(rc.Geometry.Point3d(0, 0, abs(w/2)), rc.Geometry.Vector3d.ZAxis), abs(w/2), abs(l/2), abs(h/2))\n        lum_poly.Transform(transf)\n    # Implies the luminous opening is a horizontal cylinder\n    elif w < 0 and l > 0 and h < 0 and round(w, 2) == round(h, 2):\n        lum_circ = rc.Geometry.Circle(rc.Geometry.Plane.WorldYZ,rc.Geometry.Point3d((-l/2), 0, abs(-w/2)), abs(-w/2))\n        lum_poly = rc.Geometry.Cylinder(lum_circ, l).ToBrep(True, True)\n    # Implies the luminous opening is a horizontal elliptical cylinder\n    elif w < 0 and l > 0 and h < 0 and round(w, 2) != round(h, 2):\n        cent_pt = rc.Geometry.Point3d((h/ 2), 0, abs(h/ 2))\n        lum_circ = rc.Geometry.Circle(rc.Geometry.Plane.WorldYZ, cent_pt, 1)\n        lum_poly = rc.Geometry.Cylinder(lum_circ, 1).ToNurbsSurface()\n        transf = rc.Geometry.Transform.Scale(rc.Geometry.Plane(cent_pt,rc.Geometry.Vector3d.ZAxis), abs(l), abs(w/2), abs(h/2))\n        lum_poly.Transform(transf)\n        lum_poly = lum_poly.ToBrep().CapPlanarHoles(sc.doc.ModelAbsoluteTolerance)\n    # Implies the luminous opening is a horizontal cylinder\n    elif w > 0 and l < 0 and h < 0 and round(l, 2) == round(h, 2):\n        lum_circ = rc.Geometry.Circle(rc.Geometry.Plane.WorldZX, rc.Geometry.Point3d(0, (-w/2), abs(-l/2)), abs(-l/2))\n        lum_poly = rc.Geometry.Cylinder(lum_circ, w).ToBrep(True, True)\n    # Implies the luminous opening is a horizontal elliptical cylinder\n    elif w > 0 and l < 0 and h < 0 and round(l, 2) != round(h, 2):\n        cent_pt = rc.Geometry.Point3d(0, (-w/2), abs(h/2))\n        lum_circ = rc.Geometry.Circle(rc.Geometry.Plane.WorldZX, cent_pt, 1)\n        lum_poly = rc.Geometry.Cylinder(lum_circ, 1).ToNurbsSurface()\n        transf = rc.Geometry.Transform.Scale(rc.Geometry.Plane(cent_pt, rc.Geometry.Vector3d.ZAxis), abs(l/2), abs(w), abs(h/2))\n        lum_poly.Transform(transf)\n        lum_poly = lum_poly.ToBrep().CapPlanarHoles(sc.doc.ModelAbsoluteTolerance)\n    # Implies the luminous opening is a vertical circle\n    elif w < 0 and round(l) == 0 and h < 0 and round(w, 2) == round(h, 2):\n        lum_circ = rc.Geometry.Circle(rc.Geometry.Plane.WorldYZ, origin, abs(w/2)).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_circ])[0]\n    # Implies the luminous opening is a vertical ellipse\n    elif w < 0 and round(l) == 0 and h < 0 and round(w, 2) != round(h, 2):\n        lum_ellip = rc.Geometry.Ellipse(rc.Geometry.Plane.WorldYZ, abs(w/2), abs(h/2)).ToNurbsCurve()\n        lum_poly = rc.Geometry.Brep.CreatePlanarBreps([lum_circ])[0]\n    \n    return lum_poly\n\n\ndef create_luminaire_axes(luminaire):\n    \"\"\"Draw the C0\u2013G0 axes for a Luminaire according to IES LM-63.\n    \n    Args:\n        luminare: A Honeybee Luminaire.\n    \n    Returns:\n        [C0 axis, G0 axis]\n    \"\"\"\n\n    # Ensure photometry is parsed\n    luminaire.parse_photometric_data()\n\n    # Dimensions\n    width = luminaire.width_m\n    length = luminaire.length_m\n    height = luminaire.height_m\n\n    # IES rule: circular luminaires\n    # width < 0, length == 0: use width magnitude\n    if abs(length) < 1e-6 and width < 0:\n        length = abs(width)\n\n    # Fallback if dimensions are zero\n    if abs(length) < 1e-6:\n        length = 0.5  # default\n\n    origin = Point3d(0, 0, 0)\n\n    # C0 axis\n    c0_axis = Line(\n        origin,\n        Point3d(1.2 * length / 2.0, 0, 0)\n    )\n\n    # G0 axis\n    g0_axis = Line(\n        origin,\n        Point3d(0, 0, -2.0 * length / 2.0)\n    )\n\n    return [c0_axis, g0_axis]\n\n\nif all_required_inputs(ghenv.Component):\n    scale = 1 if _scale_ is None else _scale_\n    \n    luminaire_web = luminaire_web_to_{{cad}}_breps(_luminaire, normalize=True)\n    lum_web = list_to_data_tree(place_luminaire_from_object(_luminaire, luminaire_web, scale))\n    \n    luminaire_poly = create_luminaire_brep(_luminaire)\n    lum_poly = list_to_data_tree(place_luminaire_from_object(_luminaire, luminaire_poly, scale))\n    \n    luminaire_axes = create_luminaire_axes(_luminaire)\n    lum_axes = list_to_data_tree(place_luminaire_from_object(_luminaire, luminaire_axes, scale))\n", 
  "category": "HB-Radiance", 
  "name": "HB Visualize Luminaire", 
  "description": "Visualize a Luminaire.\n_\nThis is useful to check if the the spin, tilt, and rotation is applied correctly.\n-"
}