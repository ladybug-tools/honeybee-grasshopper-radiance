{
  "version": "1.10.0", 
  "nickname": "AnnualStatistics", 
  "outputs": [
    [
      {
        "access": "None", 
        "name": "average", 
        "description": "Average illuminance or irradiance values for each sensor or timestep\nin lux or W/m2. This is either a list of values or a list of data collections\nif per_timestep_ is True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "median", 
        "description": "Median illuminance or irradiance values for each sensor or timestep\nin lux or W/m2. This is either a list of values or a list of data collections\nif per_timestep_ is True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "minimum", 
        "description": "Minimum illuminance or irradiance values for each sensor or timestep\nin lux or W/m2. This is either a list of values or a list of data collections\nif per_timestep_ is True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "maximum", 
        "description": "Maximum illuminance or irradiance values for each sensor or timestep\nin lux or W/m2. This is either a list of values or a list of data collections\nif per_timestep_ is True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "cumulative", 
        "description": "Cumulative illuminance or irradiance values for each sensor or timestep\nin lux or W/m2. This is either a list of values or a list of data collections\nif per_timestep_ is True.", 
        "type": null, 
        "default": null
      }
    ]
  ], 
  "inputs": [
    {
      "access": "item", 
      "name": "_results", 
      "description": "An list of annual Radiance result files from the \"HB Annual Daylight\"\ncomponent (containing the .ill files and the sun-up-hours.txt).\nThis can also be just the path to the folder containing these\nresult files.", 
      "type": "string", 
      "default": null
    }, 
    {
      "access": "list", 
      "name": "dyn_sch_", 
      "description": "Optional dynamic Aperture Group Schedules from the \"HB Aperture Group\nSchedule\" component, which will be used to customize the behavior\nof any dyanmic aperture geometry in the output metrics. If unsupplied,\nall dynamic aperture groups will be in their default state in for\nthe output metrics.", 
      "type": "System.Object", 
      "default": null
    }, 
    {
      "access": "list", 
      "name": "_hoys_", 
      "description": "An optional numbers or list of numbers to select the hours of the year (HOYs)\nfor which results will be computed. These HOYs can be obtained from the\n\"LB Calculate HOY\" or the \"LB Analysis Period\" components. If None, all\nhours of the results will be used.", 
      "type": "double", 
      "default": null
    }, 
    {
      "access": "item", 
      "name": "grid_filter_", 
      "description": "The name of a grid or a pattern to filter the grids. For instance,\nfirst_floor_* will simulate only the sensor grids that have an\nidentifier that starts with first_floor_. By default all the grids\nwill be processed.", 
      "type": "string", 
      "default": null
    }, 
    {
      "access": "item", 
      "name": "per_timestep_", 
      "description": "Set to True to calculate statistics per-timestep instead of per-sensor.", 
      "type": "bool", 
      "default": null
    }
  ], 
  "subcategory": "4 :: Results", 
  "code": "\nimport os\nimport json\nimport subprocess\n\ntry:\n    from ladybug.datacollection import HourlyContinuousCollection\n    from ladybug.futil import write_to_file\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n\ntry:\n    from honeybee.config import folders\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\ntry:\n    from honeybee_radiance_postprocess.dynamic import DynamicSchedule\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee_radiance:\\n\\t{}'.format(e))\n\ntry:\n    from pollination_handlers.outputs.helper import read_sensor_grid_result\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import pollination_handlers:\\n\\t{}'.format(e))\n\ntry:\n    from ladybug_{{cad}}.{{plugin}} import all_required_inputs, list_to_data_tree,   \\\n        give_warning\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_{{cad}}:\\n\\t{}'.format(e))\n\n\nif all_required_inputs(ghenv.Component):\n    # compute the annual summary\n    grid_filter_ = '*' if grid_filter_ is None else grid_filter_\n    res_folder = _results\n    per_timestep = False if per_timestep_ is None else per_timestep_\n    \n    # check to see if results use the newer numpy arrays\n    if os.path.isdir(os.path.join(res_folder, '__static_apertures__')) or \\\n        os.path.isfile(os.path.join(res_folder, 'grid_states.json')):\n        cmds = [folders.python_exe_path, '-m', 'honeybee_radiance_postprocess',\n                'post-process', 'annual-statistics', res_folder, '-sf',\n                'statistics']\n        if len(_hoys_) != 0:\n            hoys_str = '\\n'.join(str(h) for h in _hoys_)\n            hoys_file = os.path.join(res_folder, 'hoys.txt')\n            write_to_file(hoys_file, hoys_str)\n            cmds.extend(['--hoys-file', hoys_file])\n        if grid_filter_ != '*':\n            cmds.extend(['--grids-filter', grid_filter_])\n        if len(dyn_sch_) != 0:\n            if os.path.isfile(os.path.join(res_folder, 'grid_states.json')):\n                dyn_sch = dyn_sch_[0] if isinstance(dyn_sch_[0], DynamicSchedule) else \\\n                    DynamicSchedule.from_group_schedules(dyn_sch_)\n                dyn_sch_file = dyn_sch.to_json(folder=res_folder)\n                cmds.extend(['--states', dyn_sch_file])\n            else:\n                msg = 'No dynamic aperture groups were found in the Model.\\n' \\\n                    'The input dynamic schedules will be ignored.'\n                print(msg)\n                give_warning(ghenv.Component, msg)\n        \n        if per_timestep:\n            cmds.extend(['--timestep'])\n        \n        use_shell = True if os.name == 'nt' else False\n        custom_env = os.environ.copy()\n        custom_env['PYTHONHOME'] = ''\n        process = subprocess.Popen(\n            cmds, cwd=res_folder, shell=use_shell, env=custom_env,\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = process.communicate()  # wait for the process to finish\n        print(stderr)\n        if process.returncode != 0:\n            raise ValueError('Failed to compute annual statistics values.')\n        \n        res_dir = os.path.join(res_folder, 'statistics')\n        average_values_dir = os.path.join(res_dir, 'average_values')\n        median_values_dir = os.path.join(res_dir, 'median_values')\n        minimum_values_dir = os.path.join(res_dir, 'minimum_values')\n        maximum_values_dir = os.path.join(res_dir, 'maximum_values')\n        cumulative_values_dir = os.path.join(res_dir, 'cumulative_values')\n        \n        if per_timestep is False:\n            average = list_to_data_tree(read_sensor_grid_result(average_values_dir, 'average', 'full_id', False))\n            median = list_to_data_tree(read_sensor_grid_result(median_values_dir, 'median', 'full_id', False))\n            minimum = list_to_data_tree(read_sensor_grid_result(minimum_values_dir, 'minimum', 'full_id', False))\n            maximum = list_to_data_tree(read_sensor_grid_result(maximum_values_dir, 'maximum', 'full_id', False))\n            cumulative = list_to_data_tree(read_sensor_grid_result(cumulative_values_dir, 'cumulative', 'full_id', False))\n        else:\n            with open(os.path.join(average_values_dir, 'grids_info.json')) as json_file:\n                grids_info = json.load(json_file)\n            average = []\n            median = []\n            minimum = []\n            maximum = []\n            cumulative = []\n            for grid_info in grids_info:\n                with open(os.path.join(average_values_dir, '{}_average.json'.format(grid_info['full_id']))) as json_file:\n                    data_dict = json.load(json_file)\n                average.append(HourlyContinuousCollection.from_dict(data_dict))\n                with open(os.path.join(median_values_dir, '{}_median.json'.format(grid_info['full_id']))) as json_file:\n                    data_dict = json.load(json_file)\n                median.append(HourlyContinuousCollection.from_dict(data_dict))\n                with open(os.path.join(minimum_values_dir, '{}_minimum.json'.format(grid_info['full_id']))) as json_file:\n                    data_dict = json.load(json_file)\n                minimum.append(HourlyContinuousCollection.from_dict(data_dict))\n                with open(os.path.join(maximum_values_dir, '{}_maximum.json'.format(grid_info['full_id']))) as json_file:\n                    data_dict = json.load(json_file)\n                maximum.append(HourlyContinuousCollection.from_dict(data_dict))\n                with open(os.path.join(cumulative_values_dir, '{}_cumulative.json'.format(grid_info['full_id']))) as json_file:\n                    data_dict = json.load(json_file)\n                cumulative.append(HourlyContinuousCollection.from_dict(data_dict))\n            average = list_to_data_tree(average)\n            median = list_to_data_tree(median)\n            minimum = list_to_data_tree(minimum)\n            maximum = list_to_data_tree(maximum)\n            cumulative = list_to_data_tree(cumulative)\n    else:\n        msg = 'Annual Statistics is only supported for Annual Daylight and Annual Irradiance ' \\\n            'simulations with NumPy arrays.'\n        print(msg)\n        give_warning(ghenv.Component, msg)", 
  "category": "HB-Radiance", 
  "name": "HB Annual Statistics", 
  "description": "Calculate typical statistics (Average, median, minimum, maximum, sum) for an\nannual daylight or irradiance simulation.\nStatistics can either be computed per sensor or per timestep.\n-"
}